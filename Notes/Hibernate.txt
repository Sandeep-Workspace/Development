Hibernate
==========
A framework for persisting/saving Java objects in database.

Java App -> Hibernate -> Database

Benefits
---------------------------------------
Hibernate handles all low level sql
Minimize amount of JDBC code you have to develop
Hibernate provides Object to Relational mapping.(ORM)


ORM
======
Developer defines mapping between java classes and database table.
(Java class same field in db table)

Saving object with hibernate
create object
int id = (Integer)session.save(theStudent); //session is hibernate object 
Hibernate returns primary key on saving object

Retrieving object from using primary key
Object object = session.get(Student.class,primarykey);

Below we are using Hibernate Query Language
=============================================
Quering for Java Objects
Query query =session.createQuery("from ClassName");
List<ClassName> listObject =query.list();

Above code will give all data from db table

Hibernate uses JDBC for all database communication.It is another layer of abstraction on top of JDBC.

Hibernate Annotation
========================
Entity Class
Java class that is mapped to database table.

Two options for mapping 
XML config file
Java annotation

@Id for primary key annotation

@Column(name="first_name")
private String firstName;


SessionFactory : Reads hibernate config file, create session objects, Only create once in your app then reuse SessionFactory.

Session is wrapper around JDBC connection.
Main object is to save/retrieve objects.
short lived objectretrieved from seesion factory


save a object 
create session factory
get session from session factory object
create object of class you want to store
begin transaction
session.save(object);
session.getTransaction.commit();

@GeneratedValue(strategy=GenerationType.IDENTITY) to specify these field should be used for generation


Hibernate Query Language
===========================
Query Language for retrieving objects.
Similar in nature to SQL.
where,Like,order by,join,in etc..

Retrieving All students
========================
List<Student> theStudents = session.createQuery("from Student").getResultList();

In above query we have to Java Class name(Student) instead of table name.

Retrieve Student whose last name is Singh
============================================
List<Student> theStudents = session.createQuery("from Student s where s.lastName='Singh'").getResultList();

In above query use Java property name (not column name)

Retrieving Student using OR predicate
======================================
List<Student> theStudents = session.createQuery("from Student s where s.lastName='Singh'"+" OR s.firstName='Sachin').getResultList();

In above query use Java property name (not column name)

Retrieving Student using Like Predicate
========================================
List<Student> theStudents = session.createQuery("from Student s where"+"s.email LIKE '%luv2code.com'").getResultList();

In above query use Java property name (not column name)


CasCade
========
We can cascade operations. Apply the same operation to related entities.
If we delete Instructr, we should also delete their instructor_detail. This is know as "CASCADE DELETE".

Fetch Type:Eager vs Lazy Loading
==================================
When we fetch retrieve data should we retrieve everything?
Eager will retrieve everything.
Lazy will retrieve on request.

Foreign Key: Main purpose is to preserve relationship between tables.
Referential Integrity:Prevents operations that would destroy relationship.

Als ensure only valid data is inserted into the foreign key column. It can only contain valid reference to primary key in other table.

@JoinColumn(name="column name of foreign key specified in this table")

//set up mapping to instructordetail entity
	@OneToOne(cascade = CascadeType.ALL)
	@JoinColumn(name="instructor_detail_id")
	private InstructorDetail instructorDetail;
	
//	@OneToOne(mappedBy = instructorDetail)
	private Instructor instructor;
	
mappedBy refers to InstructorDetail property in Instructor class.

mappedBy tells Hibernate:
Look at the instructorDetail property in the Instructor class.
Use information from the Instructor class @JoinColumn.
To help find associated instructor.


Real World Project Requirement
================================
Delete instructor but do not delete course
delete course but do not delete instructor

Simply means: do not apply cascading delete


@OneToMany annotation provide cascade type with it.
@JoinColumn this annotation is udes to provide name of column with which we are joining(foreign key). It is used in class 
where we want to create this key

mappedBy = use on target  field where we want to join. use name in mapped by which is provided in source class.

@OneToMany annotation provide cascade type with it.


Eager Loading
==============
It will load all dependent entities.
Load everything at once.


Best Practice
==============
Only load data when absolutely needed. Prefer Lazy Loading instead of Eager Loading.

Lazy Loading
===============
It will load main entity first.
Load dependent entities on demand.

FetchType
==========
When you define Mapping Relationship
You can specify the fetch type: EAGER or LAZY.

@OneToMany(fetch = FetchType.LAZY, mappedBy ="instructor")

More about Lazy Loading
When you lazy load, the data is only retrieved on demand.
However, this requires an open Hibernate session.
need an connection to database to retrieve data.

If the Hibernate session is closed. And we attempt to retrieve data. Hibernate will throw an exception.

Retrieve Lazy data using:
=========================
Option 1:session.get() and call appropriate getter methods.
Option 2:Hibernate query with HQL.





























